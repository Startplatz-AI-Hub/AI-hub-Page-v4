<!-- Scroll-3D Morph Section (Three.js + GSAP ScrollTrigger) — single-file demo -->
<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Scroll 3D Morph Section</title>
  <style>
    :root{
      --bg0:#070A12;
      --bg1:#0B1022;
      --text:#E9ECFF;
      --muted:rgba(233,236,255,.72);
      --glass:rgba(255,255,255,.08);
      --border:rgba(255,255,255,.16);
      --shadow:0 20px 60px rgba(0,0,0,.45);
      --r:20px;
    }
    html,body{height:100%;}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      color:var(--text);
      background:
        radial-gradient(1200px 800px at 40% 10%, #18205a 0%, rgba(24,32,90,0) 60%),
        radial-gradient(1000px 700px at 70% 30%, #2b1b52 0%, rgba(43,27,82,0) 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      overflow-x:hidden;
    }
    .wrap{max-width:1100px; margin:0 auto; padding:48px 20px;}

    header.hero{padding:56px 0 30px;}
    .kicker{color:var(--muted); letter-spacing:.16em; text-transform:uppercase; font-size:12px;}
    h1{margin:14px 0 0; font-weight:750; font-size: clamp(32px, 4.5vw, 54px); line-height:1.05;}
    p.lead{margin:14px 0 0; max-width:70ch; color:var(--muted); font-size:16px;}

    /* Scroll stage: pinned by GSAP ScrollTrigger */
    #stage{position:relative;}
    .sticky{
      position: relative; /* ScrollTrigger pins this element */
      height: 100vh;
      overflow:hidden;
      border-top:1px solid rgba(255,255,255,.06);
      border-bottom:1px solid rgba(255,255,255,.06);
      background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.01));
    }

    canvas#c{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      display:block;
    }

    .hud{
      position:absolute;
      inset: 18px 18px auto auto;
      display:flex;
      flex-direction:column;
      gap:10px;
      pointer-events:none;
      z-index:3;
    }
    .pill{
      pointer-events:none;
      padding:10px 12px;
      border-radius:999px;
      background: var(--glass);
      border:1px solid var(--border);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      font-size:13px;
      color:var(--muted);
      user-select:none;
    }

    .hint{
      position:absolute;
      left:18px;
      bottom:18px;
      max-width:min(620px, calc(100% - 36px));
      padding:14px;
      border-radius:var(--r);
      background: linear-gradient(180deg, var(--glass), rgba(255,255,255,.06));
      border:1px solid var(--border);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      z-index:3;
    }
    .hint b{color:var(--text);} 
    .hint .sub{margin-top:8px; color:var(--muted); font-size:13px; line-height:1.35;}

    /* Floating labels that follow 3D cards */
    .labels{position:absolute; inset:0; z-index:4; pointer-events:none;}
    .label{
      position:absolute;
      pointer-events:auto;
      transform: translate(-50%, -50%);
      padding:10px 12px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.35);
      backdrop-filter: blur(8px);
      color:var(--text);
      font-size:13px;
      box-shadow: 0 14px 40px rgba(0,0,0,.35);
      cursor:pointer;
      user-select:none;
      opacity:0;
      transition: opacity .2s ease, transform .2s ease;
      white-space:nowrap;
    }
    .label:hover{transform: translate(-50%, -50%) scale(1.04);}

    /* Modal */
    .modalWrap{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,.45);
      z-index:50;
      padding: 24px;
    }
    .modal{
      width: min(720px, 100%);
      border-radius: 24px;
      background: linear-gradient(180deg, rgba(18,22,40,.92), rgba(12,14,26,.92));
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: 0 30px 90px rgba(0,0,0,.6);
      backdrop-filter: blur(14px);
      overflow:hidden;
    }
    .modal header{
      padding: 18px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      border-bottom:1px solid rgba(255,255,255,.10);
    }
    .modal header .t{font-weight:700; letter-spacing:.01em;}
    .modal header button{
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
      color:var(--text);
      padding:10px 12px;
      border-radius: 12px;
      cursor:pointer;
    }
    .modal .content{padding:18px 18px 20px; color:var(--muted); line-height:1.55; white-space:pre-wrap;}

    /* Footer filler content */
    .cards{display:grid; grid-template-columns: repeat(12, 1fr); gap:14px; margin:40px 0 80px;}
    .card{
      grid-column: span 6;
      padding:16px;
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
    }
    .card h3{margin:0 0 8px; font-size:16px;}
    .card p{margin:0; color:var(--muted); font-size:14px; line-height:1.45;}

    @media (max-width: 760px){
      .cards .card{grid-column: span 12;}
      .hud{inset: 14px 14px auto auto;}
      .hint{left:14px; right:14px; bottom:14px;}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header class="hero">
      <div class="kicker">Scroll + 3D</div>
      <h1>Drei Figuren, Scroll‑Approach & Morph zu Klick‑Sektionen</h1>
      <p class="lead">
        Scrolle runter: Erst kommen die Figuren näher, dann morphen sie zu drei Cards.
        Ab der letzten Phase kannst du die Cards <b>hovern</b> und <b>anklicken</b>.
      </p>
      <p class="lead" style="margin-top:10px; font-size:14px; color:var(--muted)">
        Wichtig: Bitte über einen lokalen Server öffnen (wegen ES‑Module Imports), z.B. <code>python3 -m http.server 5173</code>.
      </p>
    </header>
  </div>

  <section id="stage" aria-label="3D Scroll Section">
    <div class="sticky">
      <canvas id="c"></canvas>

      <div class="hud">
        <div class="pill" id="phasePill">Phase: –</div>
        <div class="pill" id="progressPill">Scroll: 0%</div>
      </div>

      <div class="labels" id="labels">
        <button class="label" id="lbl0" type="button">Sektion 1</button>
        <button class="label" id="lbl1" type="button">Sektion 2</button>
        <button class="label" id="lbl2" type="button">Sektion 3</button>
      </div>

      <div class="hint">
        <b>Bedienung:</b> Scrollen steuert die Animation.
        <div class="sub">
          Dieses Demo nutzt bewusst ein „cinematic fake morph“ (Fade/Scale/Position). Als nächster Step können wir echte GLTF‑Morph Targets integrieren.
        </div>
      </div>
    </div>
  </section>

  <div class="wrap">
    <div class="cards">
      <div class="card"><h3>Weiterbauen</h3><p>Du kannst hier später echte Inhalte platzieren, zu denen die Cards navigieren (Scroll-to / Route / Modal).</p></div>
      <div class="card"><h3>Performance</h3><p>Für Mobile: weniger Polys, keine schweren Post-Effects, und „prefers-reduced-motion“ respektieren.</p></div>
      <div class="card"><h3>Look & Feel</h3><p>Wenn du eine bestimmte Stilrichtung willst (minimal / neon / realistisch), sag kurz Bescheid.</p></div>
      <div class="card"><h3>Assets</h3><p>Für echte Figuren: GLB/GLTF aus Blender. Dann kannst du Morph Targets oder Shader-Transitions nutzen.</p></div>
    </div>
  </div>

  <div class="modalWrap" id="modalWrap" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal">
      <header>
        <div class="t" id="modalTitle">Sektion</div>
        <button type="button" id="closeBtn">Schließen</button>
      </header>
      <div class="content" id="modalContent"></div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { gsap } from 'https://esm.sh/gsap@3.12.5';
    import { ScrollTrigger } from 'https://esm.sh/gsap@3.12.5/ScrollTrigger';
    gsap.registerPlugin(ScrollTrigger);

    // ---------- Helpers ----------
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const lerp = (a, b, t) => a + (b - a) * t;
    const easeInOut = (t) => (t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t + 2, 2)/2);
    const smoothstep = (a, b, x) => {
      const t = clamp((x - a) / (b - a), 0, 1);
      return t * t * (3 - 2*t);
    };
    const easeOutBack = (t, s = 1.35) => {
      const x = clamp(t, 0, 1) - 1;
      return 1 + (s + 1) * x * x * x + s * x * x;
    };

    // ---------- DOM refs ----------
    const canvas = document.getElementById('c');
    const stage = document.getElementById('stage');
    const phasePill = document.getElementById('phasePill');
    const progressPill = document.getElementById('progressPill');
    const labelsEl = document.getElementById('labels');
    const labelButtons = [
      document.getElementById('lbl0'),
      document.getElementById('lbl1'),
      document.getElementById('lbl2'),
    ];

    const modalWrap = document.getElementById('modalWrap');
    const modalTitle = document.getElementById('modalTitle');
    const modalContent = document.getElementById('modalContent');
    const closeBtn = document.getElementById('closeBtn');

    function openModal(i){
      const titles = ['Sektion 1 – Konzept', 'Sektion 2 – Features', 'Sektion 3 – Kontakt'];
      const bodies = [
        'Hier könntest du z.B. eine kurze Value Proposition zeigen.\n\nDemo: Klick kam aus 3D (Raycast) oder Label.',
        'Hier könntest du 3–5 Key Features präsentieren.\n\nDemo: Hover/Click auf Karten aktiv ab Phase 3.',
        'Hier könntest du CTA + Kontakt/Termin/Newsletter einbauen.\n\nDemo: Alles ist Scroll‑gesteuert.'
      ];
      modalTitle.textContent = titles[i] ?? 'Sektion';
      modalContent.textContent = bodies[i] ?? '';
      modalWrap.style.display = 'flex';
      modalWrap.setAttribute('aria-hidden','false');
    }
    function closeModal(){
      modalWrap.style.display = 'none';
      modalWrap.setAttribute('aria-hidden','true');
    }
    closeBtn.addEventListener('click', closeModal);
    modalWrap.addEventListener('click', (e)=>{ if(e.target === modalWrap) closeModal(); });
    window.addEventListener('keydown', (e)=>{ if(e.key === 'Escape') closeModal(); });

    // ---------- Three.js setup ----------
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.05;
    renderer.setClearColor(0x000000, 0);

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x070a12, 8, 30);

    const camera = new THREE.PerspectiveCamera(42, 1, 0.1, 100);
    camera.position.set(0, 1.25, 8);

    scene.add(new THREE.AmbientLight(0xffffff, 0.55));

    const key = new THREE.DirectionalLight(0xffffff, 1.2);
    key.position.set(4, 8, 6);
    scene.add(key);

    const rim = new THREE.DirectionalLight(0xffffff, 0.7);
    rim.position.set(-6, 4, -8);
    scene.add(rim);

    // Ground
    {
      const groundGeo = new THREE.PlaneGeometry(200, 200);
      const groundMat = new THREE.MeshStandardMaterial({ color: 0x0a0d19, roughness: 1, metalness: 0 });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI/2;
      ground.position.y = -0.75;
      scene.add(ground);
    }

    // Backplate
    {
      const backGeo = new THREE.PlaneGeometry(40, 24);
      const backMat = new THREE.MeshStandardMaterial({ color: 0x0b1022, roughness: 1, metalness: 0 });
      const back = new THREE.Mesh(backGeo, backMat);
      back.position.set(0, 6, -18);
      scene.add(back);
    }

    // ---------- Figures & cards ----------
    const figures = [];
    const cardMeshes = [];

    const figureColors = [0x7aa2ff, 0xb48cff, 0x7cffc8];
    const cardColors   = [0x142045, 0x1d1445, 0x123a31];

    function makeFigure(i){
      const root = new THREE.Group();

      // Figure: capsule + head
      const bodyGeo = new THREE.CapsuleGeometry(0.48, 1.25, 10, 18);
      const bodyMat = new THREE.MeshStandardMaterial({
        color: figureColors[i], roughness: 0.35, metalness: 0.22, transparent:true, opacity:1
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);

      const headGeo = new THREE.SphereGeometry(0.34, 24, 18);
      const headMat = new THREE.MeshStandardMaterial({
        color: 0xffffff, roughness: 0.25, metalness: 0.18, transparent:true, opacity:1
      });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.set(0, 1.12, 0.12);

      const figureGroup = new THREE.Group();
      figureGroup.add(body, head);
      figureGroup.position.y = 0.12;
      root.add(figureGroup);

      // Card
      const cardGeo = new THREE.BoxGeometry(2.2, 1.25, 0.12);
      const cardMat = new THREE.MeshStandardMaterial({
        color: cardColors[i], roughness: 0.35, metalness: 0.35, transparent:true, opacity:0
      });
      const card = new THREE.Mesh(cardGeo, cardMat);
      card.position.set(0, 0.4, 0);
      card.rotation.y = 0.15 * (i-1);

      const faceGeo = new THREE.PlaneGeometry(2.05, 1.10);
      const faceMat = new THREE.MeshStandardMaterial({
        color: 0xffffff, roughness: 0.6, metalness: 0.0, transparent:true, opacity:0.0
      });
      const face = new THREE.Mesh(faceGeo, faceMat);
      face.position.set(0, 0, 0.065);
      card.add(face);

      root.add(card);

      // Initial layout
      const x0 = (i - 1) * 2.35;
      root.position.set(x0, 0, -10.0);

      return { root, figureGroup, body, head, card, face };
    }

    for (let i=0;i<3;i++){
      const obj = makeFigure(i);
      scene.add(obj.root);
      figures.push(obj);
      cardMeshes.push(obj.card);
    }

    // ---------- Scroll (GSAP ScrollTrigger) ----------
    const reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    let targetProg = 0;   // 0..1 (from ScrollTrigger)
    let smoothProg = 0;   // damped version
    let scrollTrigger = null;

    function getFallbackProgress(){
      // If ScrollTrigger fails for any reason
      const rect = stage.getBoundingClientRect();
      const total = Math.max(1, stage.offsetHeight - window.innerHeight);
      const scrolled = -rect.top;
      return clamp(scrolled / total, 0, 1);
    }

    function getProgress(){
      if (reducedMotion) return targetProg;
      return scrollTrigger ? targetProg : getFallbackProgress();
    }

    function setupScroll(){
      if (reducedMotion) return;
      if (scrollTrigger) scrollTrigger.kill();

      const stickyEl = stage.querySelector('.sticky');
      const isNarrow = window.innerWidth < 760;
      const duration = Math.round(window.innerHeight * (isNarrow ? 2.6 : 2.9));

      scrollTrigger = ScrollTrigger.create({
        trigger: stage,
        start: 'top top',
        end: `+=${duration}`,
        pin: stickyEl,
        pinSpacing: true,
        scrub: 0.85,
        anticipatePin: 1,
        onUpdate: (self) => { targetProg = self.progress; },
        onRefresh: (self) => { targetProg = self.progress; },
      });

      targetProg = scrollTrigger.progress;
      smoothProg = targetProg;
    }

    function phaseName(t){
      if (t < 1) return '1/3 – Figuren kommen näher';
      if (t < 2) return '2/3 – Morph zu Cards';
      return '3/3 – Interaktiv (hover + click)';
    }

    // ---------- Interactivity (raycast) ----------
    const raycaster = new THREE.Raycaster();
    const pointerNDC = new THREE.Vector2(10,10); // offscreen default
    let hoveredIndex = -1;
    let lastClickable = false;

    function setPointerFromEvent(e){
      const r = renderer.domElement.getBoundingClientRect();
      const x = ((e.clientX - r.left) / r.width) * 2 - 1;
      const y = -(((e.clientY - r.top) / r.height) * 2 - 1);
      pointerNDC.set(x, y);
    }

    renderer.domElement.addEventListener('pointermove', (e)=>{ setPointerFromEvent(e); });
    renderer.domElement.addEventListener('pointerdown', (e)=>{ setPointerFromEvent(e); });
    renderer.domElement.addEventListener('click', (e)=>{
      setPointerFromEvent(e);
      if (!lastClickable) return;
      if (hoveredIndex >= 0) openModal(hoveredIndex);
    });

    labelButtons.forEach((btn, i)=> btn.addEventListener('click', ()=> openModal(i)));

    // ---------- Resize + ScrollTrigger refresh ----------
    function resize(){
      const parent = renderer.domElement.parentElement;
      const w = parent.clientWidth;
      const h = parent.clientHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }

    function onResize(){
      resize();
      if (!reducedMotion){
        setupScroll();
        ScrollTrigger.refresh();
      }
    }

    window.addEventListener('resize', onResize);
    onResize();

    // ---------- Labels (project 3D→2D) ----------
    const tmpV = new THREE.Vector3();
    const tmpP = new THREE.Vector3();

    function updateLabels(visible, alpha = 1){
      labelsEl.style.display = visible ? 'block' : 'none';
      if (!visible) return;

      const w = renderer.domElement.clientWidth;
      const h = renderer.domElement.clientHeight;

      for (let i=0;i<3;i++){
        const card = figures[i].card;
        card.getWorldPosition(tmpV);
        tmpV.y += 0.72;
        tmpP.copy(tmpV).project(camera);

        const inFront = tmpP.z < 1;
        const x = (tmpP.x * 0.5 + 0.5) * w;
        const y = (-tmpP.y * 0.5 + 0.5) * h;

        const btn = labelButtons[i];
        btn.style.left = `${x}px`;
        btn.style.top = `${y}px`;
        btn.style.opacity = `${inFront ? clamp(alpha, 0, 1) : 0}`;
      }
    }

    // ---------- Scene update ----------
    function updateScene(t, time){
      // Camera
      const camZ = (t < 1) ? lerp(8, 6.2, easeInOut(t)) : 6.2;
      camera.position.set(0, lerp(1.25, 1.15, smoothstep(1.0, 2.0, t)), camZ);
      camera.lookAt(0, 0.55, -4.6);

      // Click mode
      lastClickable = (t >= 2.0);

      // Hover test
      hoveredIndex = -1;
      if (lastClickable){
        raycaster.setFromCamera(pointerNDC, camera);
        const hits = raycaster.intersectObjects(cardMeshes, false);
        if (hits.length) hoveredIndex = cardMeshes.indexOf(hits[0].object);
      }
      renderer.domElement.style.cursor = (lastClickable && hoveredIndex >= 0) ? 'pointer' : 'default';

      // Responsive layout
      const isNarrow = renderer.domElement.clientWidth < 720;
      const approachSpacing = isNarrow ? 1.55 : 2.35;
      const cardSpacing = isNarrow ? 1.90 : 2.75;
      const cardScaleBase = isNarrow ? 0.92 : 1.0;

      for (let i=0;i<3;i++){
        const f = figures[i];
        const xApproach = (i - 1) * approachSpacing;
        const xCards    = (i - 1) * cardSpacing;

        if (t < 1){
          const p = easeInOut(t);
          f.root.position.set(xApproach, 0, lerp(-10.0, -4.2, p));

          const bob = Math.sin(time*2.8 + i*0.9) * 0.04;
          f.figureGroup.position.y = 0.12 + bob;
          f.figureGroup.rotation.y = Math.sin(time*0.6 + i) * 0.12;

          f.body.material.opacity = 1;
          f.head.material.opacity = 1;
          f.figureGroup.scale.setScalar(1);

          f.card.material.opacity = 0;
          f.face.material.opacity = 0;
          f.card.scale.setScalar(0.86 * cardScaleBase);
          f.card.position.set(0, 0.4, 0);
          f.card.rotation.x = 0;
        }
        else if (t < 2){
          const raw = t - 1;
          const p = easeInOut(raw);
          const pb = easeOutBack(p);

          f.root.position.x = lerp(xApproach, xCards, p);
          f.root.position.z = lerp(-4.2, -2.25, p);

          f.body.material.opacity = lerp(1, 0, p);
          f.head.material.opacity = lerp(1, 0, p);
          f.figureGroup.scale.setScalar(lerp(1.0, 0.78, p));
          f.figureGroup.position.y = lerp(0.12, -0.10, p);

          f.card.material.opacity = lerp(0, 1, p);
          f.face.material.opacity = lerp(0, 0.12, p);
          f.card.scale.setScalar(lerp(0.86 * cardScaleBase, 1.0 * cardScaleBase, pb));
          f.card.position.y = lerp(0.4, 0.78, pb);
          f.card.rotation.y = lerp(0.15*(i-1), 0.07*(i-1), p);
        }
        else {
          f.root.position.set(xCards, 0, -2.25);

          f.body.material.opacity = 0;
          f.head.material.opacity = 0;
          f.figureGroup.scale.setScalar(0.78);

          f.card.material.opacity = 1;
          f.face.material.opacity = 0.12;

          const float = Math.sin(time*1.15 + i*0.9) * 0.05;
          f.card.position.y = 0.78 + float;

          const isHover = (i === hoveredIndex);
          const targetScale = (isHover ? 1.06 : 1.0) * cardScaleBase;
          f.card.scale.setScalar(lerp(f.card.scale.x, targetScale, 0.18));

          const tilt = isHover ? 0.06 : 0.0;
          f.card.rotation.x = lerp(f.card.rotation.x, -tilt, 0.18);
          f.card.rotation.y = lerp(f.card.rotation.y, 0.07*(i-1), 0.18);
          f.face.material.opacity = lerp(f.face.material.opacity, isHover ? 0.22 : 0.12, 0.18);
        }
      }

      const labelsVisible = (t > 1.55);
      const labelsAlpha = smoothstep(1.55, 1.85, t);
      updateLabels(labelsVisible, labelsAlpha);
    }

    // ---------- Self-tests (lightweight) ----------
    function runSelfTests(){
      try {
        console.assert(!!THREE, 'THREE should be loaded');
        console.assert(!!gsap && !!ScrollTrigger, 'GSAP + ScrollTrigger should be loaded');
        console.assert(figures.length === 3, 'Should have exactly 3 figures');
        console.assert(cardMeshes.length === 3, 'Should have exactly 3 cards');
        console.log('[SelfTest] OK');
      } catch (e) {
        console.warn('[SelfTest] failed', e);
      }
    }
    runSelfTests();

    // ---------- Main loop ----------
    const clock = new THREE.Clock();

    // Reduced motion: show the cards state without scroll-driven motion.
    if (reducedMotion){
      targetProg = 0.72;
      smoothProg = targetProg;
    } else {
      setTimeout(()=>ScrollTrigger.refresh(), 50);
    }

    function animate(){
      const time = clock.getElapsedTime();
      const rawProg = getProgress();
      smoothProg = lerp(smoothProg, rawProg, 0.08);
      const prog = smoothProg;
      const t = prog * 3;

      phasePill.textContent = `Phase: ${phaseName(t)}`;
      progressPill.textContent = `Scroll: ${Math.round(prog*100)}%`;

      updateScene(t, time);
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();
  </script>
</body>
</html>
